// import { engineLogger } from "../logger";
import { Storage } from "./storage/Storage";
import { createContext, TypeCellContext } from "./context";
import {
  createExecutionScope,
  getModulesFromTypeCellCode,
  ModuleExecution,
  runModule,
} from "./engine";
import { importTypeCell } from "./importTypeCell";

const cachedImportEvaluators = new Map<
  string,
  ReturnType<typeof createImportEvaluator>
>();

export function getImportEvaluator(moduleName: string, cacheKey: string) {
  const totalCacheKey = moduleName + "$" + cacheKey;
  if (!cachedImportEvaluators.has(totalCacheKey)) {
    const observableContext = createContext(
      {} as any // TODO
    );
    cachedImportEvaluators.set(
      totalCacheKey,
      createImportEvaluator(observableContext, moduleName)
    );
  }
  return cachedImportEvaluators.get(totalCacheKey)!;
}

export function createImportEvaluator(
  typecellContext: TypeCellContext,
  moduleName: string
) {
  if (!moduleName.startsWith("!@")) {
    throw new Error("not a TypeCell import");
  }
  const [owner, slug] = moduleName.substr(2).split("/", 2);

  let executionPromise: Promise<TypeCellContext> | undefined;

  const executionScope = createExecutionScope(typecellContext, {}); // TODO: scope

  function evaluateCached() {
    if (!executionPromise) {
      executionPromise = evaluate();
    }
    return executionPromise;
  }

  const executionContexts: ModuleExecution[] = [];

  async function evaluate() {
    const compiledCode = await importTypeCell(owner, slug);

    const modules = getModulesFromTypeCellCode(
      compiledCode.jsCode,
      executionScope
    );
    if (modules.length === 0) {
      throw new Error("expected more than 0 modules");
    }

    const executionContexts = await Promise.all(
      modules.map(async (mod) => {
        // engineLogger.log("running module", cell.id, mod.name);
        const execution = await runModule(
          mod,
          typecellContext,
          () => {},
          () => {},
          () => {}
        );
        return execution;
      })
    );

    const settled = await Promise.allSettled(
      executionContexts.map((ec) => ec.initialRun)
    );

    if (!settled.some((p) => p.status === "fulfilled")) {
      throw new Error(
        "expected at least one initialrun to succeed when importing typecell module"
      );
    }

    return typecellContext.context;
  }

  return {
    getModule: evaluateCached,
    dispose: () => {
      executionContexts.forEach((c) => c.dispose()); // TODO: test
    },
  };
}
