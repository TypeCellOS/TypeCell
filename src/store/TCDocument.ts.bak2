import { autorun } from "mobx";
import { IndexeddbPersistence } from "y-indexeddb";
import { WebrtcProvider } from "y-webrtc";
import * as Y from "yjs";
import { observeDoc } from "../moby/doc";
import { Ref } from "./Ref";
import slug from "speakingurl";
const documentCache = new Map<string, TCDocument>();
// (window as any).documents = documentCache;
// const subDocCache = new Map<string, Y.Doc>();

export default class TCDocument {
  private refCount = 0;
  private readonly ydoc;
  public readonly webrtcProvider: WebrtcProvider;
  public readonly indexedDBProvider: IndexeddbPersistence;

  private constructor(
    public readonly id: string,
    private readonly initialTitle?: string
  ) {
    if (!id.startsWith("@") || id.split("/").length !== 2) {
      throw new Error("invalid arguments for doc");
    }

    this.ydoc = new Y.Doc({ guid: id });
    this.webrtcProvider = new WebrtcProvider(id, this.ydoc);
    this.indexedDBProvider = new IndexeddbPersistence(id, this.ydoc);

    observeDoc(this.ydoc);
  }

  public create(type: string) {
    this.ydoc.getMap("meta").set("type", type);
    this.ydoc.getMap("meta").set("created_at", Date.now());
  }

  public static load(
    identifier:
      | string
      | { owner: string; document: string; setInitialTitle?: boolean }
  ) {
    let initialTitleToSet: string | undefined;

    if (typeof identifier !== "string") {
      const ownerSlug = slug(identifier.owner, {
        custom: {
          "@": "@", // tODO: necesary?
        },
      });
      const documentSlug = slug(identifier.document);
      if (!ownerSlug || !documentSlug) {
        throw new Error("invalid identifier");
      }

      if (!ownerSlug.startsWith("@")) {
        throw new Error("currently expecting owner to start with @");
      }

      if (identifier.setInitialTitle) {
        initialTitleToSet = identifier.document;
      }
      identifier = ownerSlug + "/" + documentSlug;
    }

    let doc = documentCache.get(identifier);
    if (!doc) {
      doc = new TCDocument(identifier);
      documentCache.set(identifier, doc);
      if (initialTitleToSet) {
        // doc.initialTitle = initialTitleToSet;
      }
    }
    doc.refCount++;
    return doc;
  }

  public get title(): Y.Text {
    let title: Y.Text = this.ydoc.getText("title");
    return title;
  }

  public get type(): string {
    return this.ydoc.getMap("meta").get("type");
  }

  public set type(val: string) {
    this.ydoc.getMap("meta").set("type", val);
  }

  public get refs(): Y.Map<any> {
    let map: Y.Map<any> = this.ydoc.getMap("refs");
    return map;
  }

  public removeRef(ref: Ref) {
    this.refs.delete(ref.uniqueHash() + "");
    // TODO: delete reverse?
  }

  public ensureRef(ref: Ref, checkReverse = true) {
    if (!(ref instanceof Ref)) {
      throw new Error("invalid ref passed");
    }
    const key = ref.uniqueHash() + ""; // parent: type,  // child: type, target
    let existing = this.refs.get(key);
    if (existing) {
      // already has a parent
      if (JSON.stringify(existing) !== JSON.stringify(ref.toJS())) {
        // TODO: deepequals
        // different parent
        const doc = TCDocument.load(existing.target); // TODO: unload document
        doc.removeRef(ref.reverse(this.id));
      }
    }
    this.refs.set(ref.uniqueHash() + "", ref.toJS());
    if (checkReverse) {
      const reverseDoc = TCDocument.load(ref.target);
      reverseDoc.ensureRef(ref.reverse(this.id), false);
    }
  }

  public get data(): Y.XmlFragment {
    let xml = this.ydoc.getXmlFragment("doc");
    // observeYType(subDoc);
    return xml;
    // subDoc.load();
    // return subDoc;
  }

  public dispose() {
    this.refCount--;
    if (this.refCount === 0) {
      this.webrtcProvider.destroy();
      this.indexedDBProvider.destroy();
      documentCache.delete(this.id);
    }
  }
}
